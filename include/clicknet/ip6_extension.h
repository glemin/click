/* -*- mode: c; c-basic-offset: 4 -*- */
#ifndef CLICKNET_IP6_EXTENSION_H
#define CLICKNET_IP6_EXTENSION_H

/* This file contains the structs you need when using IPv6 extension headers */

/* Hop-by-hop extension header

  There are two types of Hop-by-hop extension headers.
  - Router Alert
  - Padding
*/
struct HopByHopHeader {      // IPv6 Hop-by-Hop Option header
                                            // This is a particular Hop-By-Hop Extension header which contains two different options.
    ////////////////////////////////////////////////////////////////
    // here is the general Hop-by-Hop header part without options //
    ////////////////////////////////////////////////////////////////
    uint8_t next_header; // type of the next header (e.g. UDP is 17, or Mobility Extension header is 135).
    uint8_t hdr_ext_len; // length of the Hop-by-Hop Options header in 8-octet units, not including the first 8 octets.
    uint16_t options_and_padding1;
    uint32_t options_and_padding2;
};

struct HopByHopRouterAlertHeader {
                                            // This is a particular Hop-By-Hop Extension header which contains two different options.
    ////////////////////////////////////////////////////////////////
    // here is the general Hop-by-Hop header part without options //
    ////////////////////////////////////////////////////////////////
    uint8_t next_header; // type of the next header (e.g. UDP is 17, or Mobility Extension header is 135).
    uint8_t hdr_ext_len; // length of the Hop-by-Hop Options header in 8-octet units, not including the first 8 octets.

    //////////
    // what will follow are 2 options: the router alert option AND a padding option //
    //////////

    ///////////////////////////////////////////////
    // here follows the Router Alert Option part //
    ///////////////////////////////////////////////
    uint8_t option_type1;
    uint8_t opt_data_len1;
    uint16_t option_data1;

    //////////////////////////////////////////////////////////////////////////////////////////
    // here follows the padN Option part; we need padding because we need at least 8 octets //
    //////////////////////////////////////////////////////////////////////////////////////////
    uint8_t option_type2;
    uint8_t op_data_len2;
};

/* Destination extension header */
struct DestinationHeader {   
    uint8_t next_header;    // type of the next header
    uint8_t hdr_ext_len;    // length of this header in 8-octet units, not including the first 8 octets
    uint8_t routing_type;   // which sort of routing extension header do we have? currently we have 0, 1 and 2.
    uint8_t segments_left;  // number of nodes this packet still has to visit before reaching its final destination.

    // What here follows is the type-specific Data part, which is variable in length
};

/* Routing extension header */
struct RoutingHeader {   
    uint8_t next_header;    // type of the next header
    uint8_t hdr_ext_len;    // length of this header in 8-octet units, not including the first 8 octets
    uint8_t routing_type;   // which sort of routing extension header do we have? currently we have 0, 1 and 2.
    uint8_t segments_left;  // number of nodes this packet still has to visit before reaching its final destination.

    // What here follows is the type-specific Data part, which is variable in length
};



/* Fragment extension header */

struct FragmentationHeader {
    uint8_t next_header;    // type of the next header
    uint8_t reserved;       // part is reserved; initialized to all zeroes.
    uint8_t fragment_offset_part1; // fragment offset is 13 bits long; Offset, in 8-octet units, relative to the start of the fragmentable part of the original packet.
    uint8_t fragment_offset_part2_and_reserved_and_M; // the first 5 bits of this part are the remaining part of the fragment offset that stated in part 1
                                                      // the following 2 bits are reserved
                                                      // the last bit M; if M is 1 it means that more fragments follow, if it is 0 it means last fragment
    uint32_t identification; // Packet identification value, generated by the source node. Needed for reassembly of the original packet.
};

#endif
